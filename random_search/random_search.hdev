<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="13.0">
<procedure name="main">
<interface/>
<body>
<c>* ------------------------------------------------------------</c>
<c>* Random search over filter pipelines for binary segmentation</c>
<c>* Metric: Matthews Correlation Coefficient (MCC)</c>
<c>* HALCON / HDevelop script</c>
<c>* ------------------------------------------------------------</c>
<c>* ------------------------------------------------------------</c>
<c>* Read experiment parameters from parameters.txt</c>
<c>* Each line: WDIR;ImageDir;LabelDir;ResultDir;</c>
<c>* Example:</c>
<c>*   D:\evias_expmts;severstal-steel\train_cgp\imags;severstal-steel\train_cgp\labels;D:\dev\github\experiments\random_search\results;</c>
<c>* ------------------------------------------------------------</c>
<c></c>
<c>* =========================</c>
<c>* CONFIG</c>
<c>* =========================</c>
<l>ParamFile := 'parameters.txt'</l>
<c>* following parameters are irrelevant</c>
<c>* are being filled by reading the parameters</c>
<l>*ImageDir := ''</l>
<l>*LabelDir := ''</l>
<l>*ResultDir := ''</l>
<c></c>
<c>* ==========================</c>
<c>* number of random pipelines to test</c>
<l>MaxTrials := 1000</l>
<c>* max number of filters to chain (1..MaxPipelineLen)</c>
<l>MaxPipelineLen := 10                 </l>
<c>* RNG seed for reproducibility</c>
<l>Seed := 42</l>
<c>* apply a small opening to clean preds (0/1)</c>
<l>DoOpeningPost := 1</l>
<l>OpeningRadius := 2</l>
<l>open_file (ParamFile, 'input', FileHandle)</l>
<l>Parameters := []</l>
<l>while (true)</l>
<l>    fread_string(FileHandle,Line,IsEOF)</l>
<l>    if (IsEOF)</l>
<l>        break</l>
<l>    endif</l>
<l>    if (Line != '')</l>
<l>        Parameters := [Parameters, Line]</l>
<l>    endif</l>
<l>    *fnew_line (FileHandle)</l>
<l>endwhile</l>
<l>close_file (FileHandle)</l>
<c></c>
<c>* Remove header if present (check first token)</c>
<l>tuple_split(Parameters[0], ';', Tokens)</l>
<l>if (Tokens[0] == 'wdir')</l>
<l>    Parameters := Parameters[1:|Parameters|-1]</l>
<l>endif</l>
<c></c>
<c>* Prepare tuples for each column</c>
<l>WDIR := []</l>
<l>ImageDirs := []</l>
<l>LabelDirs := []</l>
<l>ResultDir := ''</l>
<c></c>
<l>for LineIdx := 0 to |Parameters|-1 by 1</l>
<l>    tuple_split(Parameters[LineIdx], ';', Parts)</l>
<l>    if (|Parts| &gt;= 4)</l>
<l>        WDIR := [WDIR, Parts[0]]</l>
<l>        ImageDirs := [ImageDirs, Parts[1]]</l>
<l>        LabelDirs := [LabelDirs, Parts[2]]</l>
<l>        ResultDir := Parts[3]</l>
<l>    endif</l>
<l>endfor</l>
<c></c>
<l>if(|ImageDirs| == 0 or |LabelDirs| == 0 or |ImageDirs| != |LabelDirs|)</l>
<l>    throw('ImageDirs and LabelDirs mismatch!')</l>
<l>endif</l>
<c></c>
<l>for RunIdx := 0 to |ImageDirs| - 1 by 1</l>
<l>    ImageDir := WDIR + '\\' + ImageDirs[RunIdx]</l>
<l>    LabelDir := WDIR + '\\' + LabelDirs[RunIdx]</l>
<c>    * =========================</c>
<c>    * PREP: load file lists</c>
<c>    * =========================</c>
<l>    list_image_files (ImageDir, 'default', [], ImageFiles)</l>
<l>    list_image_files (LabelDir, 'default', [], LabelFiles)</l>
<c>    </c>
<l>    if (|ImageFiles| = 0 or |ImageFiles| != |LabelFiles|)</l>
<l>        throw ('Image/label file lists are empty or different length.')</l>
<l>    endif</l>
<c>    </c>
<c>    * =========================</c>
<c>    * RNG setup</c>
<c>    * =========================</c>
<l>    set_system ('seed_rand', Seed)</l>
<c>    * helper to draw random int in [a,b]</c>
<c>    * rndInt := a + floor(tuple_rand(1) * (b - a + 1))</c>
<c>    </c>
<c>    * =========================</c>
<c>    * Define candidate filters and parameter ranges</c>
<c>    * (All filters operate on the current working image in the pipeline)</c>
<c>    * =========================</c>
<l>    FilterNames := ['gauss','mean','median','sobel_amp','laplace','gray_open','gray_close']</l>
<c>    </c>
<c>    * =========================</c>
<c>    * Helpers</c>
<c>    * =========================</c>
<c>    * apply_random_filter := procedure (ImageIn : ImageOut, ParamDesc : ) </c>
<c>    * mcc_region := procedure (PredRegion, GTRegion, Width, Height : MCC :) </c>
<c>    * segment_to_region := procedure (Img : RegionOut, UsedThr, SegDesc :) </c>
<c>    </c>
<c>    * =========================</c>
<c>    * Search</c>
<c>    * =========================</c>
<l>    BestMeanMCC := -1.0</l>
<l>    BestConfigDesc := ''</l>
<l>    BestTrialIdx := -1</l>
<c>    </c>
<l>    dev_update_off ()</l>
<l>    dev_close_window ()</l>
<l>    dev_open_window_fit_size(0, 0, IsEOF, IsEOF, -1, -1, WindowHandle)</l>
<c>    </c>
<c>    * ========================</c>
<c>    * Logging</c>
<c>    * ========================</c>
<l>    run_text := 'Dataset:' + ImageDirs[RunIdx] + '\n'</l>
<l>    get_system_time(MSecond1, Second1, Minute1, Hour1, Day1, YDay1, Month1, Year1)</l>
<c>    </c>
<l>    time_started := Year1 + '-' + Month1 + '-' + Day1 + ' ' + Hour1 + ':' + Minute1 + ':' + Second1</l>
<l>    run_text := run_text + 'Run Started: ' + time_started + '\n'</l>
<l>    list_of_trial_results := ''</l>
<c>    </c>
<l>    ResultDirPath := ResultDir + '\\' + \
              Year1 + \
              Month1 + \
              Day1 + \
              Hour1 + \
              Minute1 + \
              Second1 + \
              '-randsearch-result.txt'</l>
<c>    </c>
<l>    for Trial := 1 to MaxTrials by 1</l>
<l>        dev_clear_window()</l>
<l>        trial_text := run_text + 'Trial: ' + Trial + ' / ' + MaxTrials + '\n'</l>
<l>        dev_disp_text(trial_text, 'window', 12, 12, 'black', [], [])</l>
<c>    </c>
<c>        * Draw random pipeline length</c>
<l>        tuple_rand(1, Rand)</l>
<l>        PipeLen := 1 + floor(Rand * MaxPipelineLen)</l>
<c>    </c>
<c>        * Build + describe pipeline</c>
<l>        PipelineDesc := []</l>
<l>        SumMCC := 0.0</l>
<c>    </c>
<l>        for ImgIdx := 0 to |ImageFiles|-1 by 1</l>
<l>            dev_clear_window()</l>
<l>            text := trial_text + 'Image: ' + ImgIdx + ' / ' + |ImageFiles| + '\n'</l>
<l>            dev_disp_text(text, 'window', 12, 12, 'black', [], [])</l>
<l>            read_image (Img, ImageFiles[ImgIdx])</l>
<l>            read_image (GtImg, LabelFiles[ImgIdx])</l>
<c>    </c>
<c>            * Ensure single-channel byte where needed</c>
<l>            count_channels(Img, Channels)</l>
<l>            if (|Channels| &gt; 0)</l>
<c>                * no-op, common case</c>
<l>            endif</l>
<c>    </c>
<l>            get_image_size (Img, W, H)</l>
<c>    </c>
<c>            * Convert GT image to region (anything &gt; 0 is positive)</c>
<l>            threshold (GtImg, R_gt, 1, 255)</l>
<c>    </c>
<c>            * Apply random filter pipeline</c>
<l>            copy_image (Img, Work)</l>
<l>            PipeStepDesc := []</l>
<l>            for k := 1 to PipeLen by 1</l>
<l>                apply_random_filter (Work, Work, FilterNames, text, StepDesc)</l>
<l>                PipeStepDesc := [PipeStepDesc, StepDesc]</l>
<l>            endfor</l>
<c>    </c>
<c>            * Segment to region</c>
<l>            text := trial_text + 'Segment to region ...\n'</l>
<l>            dev_disp_text (text, 'window', 12, 12, 'black', [], [])</l>
<c>            * Safe wrapper for segment_to_region</c>
<c>            </c>
<l>            area_center (Work, Area, Row, Col)</l>
<l>            if (Area == 0)</l>
<l>                gen_empty_region (RegionOut)</l>
<l>                UsedThr := -1</l>
<l>                SegDesc := 'segment_failed'</l>
<l>            else</l>
<l>                segment_to_region (Work, RegionOut, UsedThr, SegDesc)</l>
<l>            endif</l>
<c>            </c>
<c>            * Optional post-processing on prediction to reduce noise</c>
<l>            *if (DoOpeningPost)</l>
<l>            *    opening_circle (RegionOut, R_pred, OpeningRadius)</l>
<l>            *endif</l>
<c>            * Add random region post-processing</c>
<c>            </c>
<l>            text := text + 'Postprocessing ...\n'</l>
<l>            dev_disp_text (text, 'window', 12, 12, 'black', [], [])</l>
<l>            postprocess_region_random (RegionOut, R_pred, PostDesc)</l>
<c>            </c>
<l>            tuple_concat(PipeStepDesc, ' -&gt; ', PipeStepDesc)</l>
<l>            PipelineDesc := 'len=' + PipeLen + ' :: ' + PipeStepDesc + ' -&gt; ' + SegDesc + ' -&gt; ' + PostDesc</l>
<c></c>
<c>            * Compute MCC</c>
<l>            get_image_size(Img, Width, Height)</l>
<l>            mcc_region (R_pred, R_gt, Width, Height, MCC)</l>
<l>            SumMCC := SumMCC + MCC</l>
<l>        endfor</l>
<c>    </c>
<l>        MeanMCC := SumMCC / |ImageFiles|</l>
<l>        tuple_concat(PipeStepDesc, ' -&gt; ', PipeStepDesc_Concat)</l>
<l>        PipelineDesc := 'len=' + PipeLen + ' :: ' + PipeStepDesc_Concat + ' -&gt; ' + SegDesc</l>
<c>    </c>
<l>        if (MeanMCC &gt; BestMeanMCC)</l>
<l>            BestMeanMCC := MeanMCC</l>
<l>            BestConfigDesc := PipelineDesc</l>
<l>            BestTrialIdx := Trial</l>
<l>        endif</l>
<c>    </c>
<c>        * (Optional) progress print</c>
<l>        dev_disp_text ('Trial ' + Trial + '/' + MaxTrials + '  Mean MCC=' + MeanMCC$'.4f', \
                       'window', \
                       'top', \
                       'left', \
                       'black', \
                       [], \
                       [])</l>
<c>        </c>
<l>        Line := Trial + ';' + MeanMCC + ';\n'</l>
<l>        write_to_file (ResultDirPath, Line)</l>
<l>    endfor</l>
<c>    </c>
<c>    * =========================</c>
<c>    * Report</c>
<c>    * =========================</c>
<l>    read_from_file (ResultDirPath, FileContent)</l>
<l>    list_of_trial_results := Trial + ';' + MeanMCC + ';\n' + FileContent</l>
<c>    </c>
<l>    get_system_time(MSecond, Second, Minute, Hour, Day, YDay, Month, Year)</l>
<c>    * --- Convert to seconds ---</c>
<c>    * A rough formula: total seconds = YDay*86400 + Hour*3600 + Min*60 + Sec + MSec/1000</c>
<c>    </c>
<l>    StartTotal := (YDay1 * 86400) + (Hour1 * 3600) + (Minute1 * 60) + Second1 + (MSecond1 / 1000.0)</l>
<l>    EndTotal   := (YDay * 86400) + (Hour * 3600) + (Minute * 60) + Second + (MSecond / 1000.0)</l>
<c></c>
<l>    DeltaTime := EndTotal - StartTotal</l>
<c>    </c>
<l>    output_string := ['--- Random Search Complete ---\n', \
                   'Time Started: ' + time_started + '\n', \
                   'Time Ended  : ' + Year + '-' + Month + '-' + Day + ' ' + Hour + ':' + Minute + ':' + Second + '\n', \
                   'Delta (sec) : ' + DeltaTime + '\n' + \
                   'ImageDirs   : ' + ImageDirs[RunIdx] + '\n', \
                   'LabelDirs   : ' + LabelDirs[RunIdx] + '\n', \
                   'No. Images  : ' + |ImageFiles|, \
                   'MaxPipelineLen: ' + MaxPipelineLen + '\n', \
                   'Trials      : ' + MaxTrials + '\n', \
                   'Best Trial  : ' + BestTrialIdx + '\n', \
                   'Best Mean MCC: ' + BestMeanMCC$'.5f' + '\n', \
                   'Best Config : ' + BestConfigDesc + '\n\n', \
                   '--- Iterations ---\n' + list_of_trial_results]</l>
<c>    </c>
<l>    open_file(ResultDirPath, \
              'output', \
              FileHandle)</l>
<l>    fwrite_string(FileHandle, output_string)</l>
<l>    close_file(FileHandle)</l>
<c>    </c>
<c>    * Example: rerun best pipeline on the first image and visualize</c>
<l>    if (|ImageFiles| &gt; 0)</l>
<l>        read_image (Img0, ImageFiles[0])</l>
<l>        read_image (Gt0, LabelFiles[0])</l>
<l>        get_image_size (Img0, W0, H0)</l>
<l>        threshold (Gt0, R_gt0, 1, 255)</l>
<c>    </c>
<c>        * Reconstruct best pipeline from description is nontrivial in pure text;</c>
<c>        * for quick visual, just run once more with the same RNG seed up to BestTrialIdx.</c>
<l>        set_system ('seed_rand', Seed)</l>
<l>        for t := 1 to BestTrialIdx-1 by 1</l>
<c>            * burn RNG to the same state the search used</c>
<l>            tuple_rand(1000, Rand)</l>
<l>            tmp := Rand</l>
<l>        endfor</l>
<c>    </c>
<c>        * Draw the same PipeLen and steps again (approximate demo)</c>
<l>        tuple_rand(1, Rand)</l>
<l>        PipeLen := 1 + floor(Rand * MaxPipelineLen)</l>
<l>        copy_image (Img0, Work0)</l>
<l>        for k := 1 to PipeLen by 1</l>
<l>            apply_random_filter (Work0, ImageOut, FilterNames, text, ParamDesc1)</l>
<l>        endfor</l>
<l>        segment_to_region (Work0, RegionOut1, UsedThr2, SegDesc2)</l>
<c>    </c>
<l>        dev_close_window ()</l>
<l>        dev_open_window_fit_image (Img0, 0, 0, -1, -1, WindowHandle)</l>
<l>        dev_display (Img0)</l>
<l>        dev_set_color ('green')</l>
<l>        dev_display (R_gt0)</l>
<l>        dev_set_color ('red')</l>
<l>        dev_display (Gt0)</l>
<l>    endif</l>
<l>endfor</l>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
<procedure name="apply_random_filter">
<interface>
<io>
<par name="ImageIn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="ImageOut" base_type="iconic" dimension="0"/>
</oo>
<ic>
<par name="FilterNames" base_type="ctrl" dimension="0"/>
<par name="text" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="ParamDesc" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* =========================</c>
<c>* Extended filter space (image -&gt; image)</c>
<c>* =========================</c>
<c>* Includes: AnisotropicDiffusion, BandpassImage(lines), BinomialFilter, CoherenceEnhancingDiff,</c>
<c>* DualRank, EliminateMinMax, EquHistoImage, GaussFilter, GrayRangeRect, HighpassImage,</c>
<c>* KirschAmp, Laplace, Roberts, SobelAmp (yours), Mean/Median/Gray Open/Close (yours)</c>
<c></c>
<c>*apply_random_filter := procedure (ImageIn : ImageOut, ParamDesc : ) </c>
<c>* Missing: </c>
<c>* 'coherence_enhancing_diff', 'anisotropic_diffusion',</c>
<l>FilterNames := ['bandpass_lines','binomial_filter',\
                    'dual_rank','eliminate_min_max','equ_histo_image','gauss_filter','gray_range_rect', \
                    'highpass_image','kirsch_amp','laplace','roberts', \
                    'gauss','mean','median','sobel_amp','gray_open','gray_close']</l>
<c></c>
<l>tuple_rand(1, Rand)</l>
<l>idx := floor(Rand * |FilterNames|)</l>
<l>if (idx &gt;= |FilterNames|)</l>
<l>    idx := |FilterNames| - 1</l>
<l>endif</l>
<l>F := FilterNames[idx]</l>
<l>ParamDesc := ''</l>
<c></c>
<l>text := text + 'Apply Filter:' + F + '\n'</l>
<l>dev_disp_text (text, 'window', 12, 12, 'black', [], [])</l>
<c></c>
<l>if (F == 'anisotropic_diffusion')</l>
<l>    *     anisotropic_diffusion(ImageIn, ImageOut, Mode, Contrast, Theta, Iterations)</l>
<c>    * Modes: 'weickert','perona-malik','parabolic'; Contrast {2,5,10,20,50,100}; Theta {0.5,1.0,3.0}; Iter {1,3,10,100,500}</c>
<l>    Modes := ['weickert','perona-malik','parabolic']</l>
<c>        </c>
<l>    tuple_rand(1, R1)</l>
<l>    m := int(floor(R1 * |Modes|))</l>
<c>        </c>
<l>    tuple_rand(1, R2)</l>
<l>    cset := [2,5,10,20,50,100]</l>
<l>    c := cset[int(floor(R2*|cset|))]</l>
<c>        </c>
<l>    tuple_rand(1, R3)</l>
<l>    tset := [0.5,1.0,3.0]</l>
<l>    th := tset[int(floor(R3*|tset|))]</l>
<c>        </c>
<l>    tuple_rand(1, R4)</l>
<l>    iset := [1,3,10,100,500]     </l>
<l>    it := iset[int(floor(R4*|iset|))]</l>
<c>    </c>
<l>    get_image_type(ImageIn, Type)</l>
<l>    if(Type != 'byte' and Type != 'uint2' and Type !=  'real')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'byte')</l>
<l>    endif</l>
<l>    anisotropic_diffusion (ImageIn, ImageOut, Modes[m], c, th, it)</l>
<l>    ParamDesc := 'anisotropic_diffusion(' + Modes[m] + ',' + c + ',' + th$'.2f' + ',' + it + ')'</l>
<c>    * (Mapped from AnisotropicDiffusion.Execute) :contentReference[oaicite:0]{index=0}</c>
<c>    </c>
<l>elseif (F == 'bandpass_lines')</l>
<l>    * bandpass_image(ImageIn, ImageOut, 'lines')</l>
<l>    get_image_type(ImageIn, Type)</l>
<l>    if(Type != 'byte' and Type != 'uint2')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'byte')</l>
<l>    endif</l>
<l>    bandpass_image (ImageIn, ImageOut, 'lines')</l>
<l>    ParamDesc := 'bandpass_image(lines)'</l>
<c>    * (BandpassImage only supports 'lines') :contentReference[oaicite:1]{index=1}</c>
<c>    </c>
<l>elseif (F == 'binomial_filter')</l>
<c>    * binomial_filter(ImageIn, ImageOut, MaskWidth, MaskHeight), odd sizes 1..37</c>
<l>    odds := [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37]</l>
<l>    tuple_rand(1, R1) </l>
<l>    mw := odds[int(floor(R1*|odds|))]</l>
<c>    </c>
<l>    tuple_rand(1, R2)</l>
<l>    mh := odds[int(floor(R2*|odds|))]</l>
<c>    </c>
<l>    get_image_type(ImageIn, Type)</l>
<l>    if(Type != 'byte' and Type != 'uint2' and Type !=  'real')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'byte')</l>
<l>    endif</l>
<l>    binomial_filter (ImageIn, ImageOut, mw, mh)</l>
<l>    ParamDesc := 'binomial_filter(' + mw + 'x' + mh + ')'</l>
<c>    * (BinomialFilter.Execute) :contentReference[oaicite:2]{index=2}</c>
<l>elseif (F == 'coherence_enhancing_diff')</l>
<l>    * coherence_enhancing_diff(ImageIn, ImageOut, Sigma, Rho, Theta, Iter)</l>
<c>    * Sigma 0..1; Rho 0..30; Theta 0.1..0.5; Iter 1..500</c>
<c>    </c>
<l>    tuple_rand(1, R1)</l>
<l>    Sigma := round(R1*10)/10.0</l>
<c>    </c>
<l>    tuple_rand(1, R2)</l>
<l>    Rho := floor(R2*31)</l>
<l>    tset := [0.1,0.2,0.3,0.4,0.5]</l>
<c>    </c>
<l>    tuple_rand(1, R3)</l>
<l>    Theta := tset[int(floor(R3*|tset|))]</l>
<c>    </c>
<l>    tuple_rand(1, R4)</l>
<l>    Iter := int(1 + floor(R4*500))</l>
<c></c>
<l>    get_image_type(ImageIn, Type)</l>
<l>    if(Type != 'byte' and Type != 'uint2' and Type !=  'real')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'byte')</l>
<l>    endif</l>
<l>    coherence_enhancing_diff (ImageIn, ImageOut, Sigma, Rho, Theta, Iter)</l>
<l>    ParamDesc := 'coherence_enhancing_diff(' + Sigma$'.1f' + ',' + Rho + ',' + Theta$'.1f' + ',' + Iter + ')'</l>
<c>    * (CoherenceEnhancingDiff.Execute) :contentReference[oaicite:3]{index=3}</c>
<c></c>
<l>elseif (F == 'dual_rank')</l>
<c>    * dual_rank(ImageIn, ImageOut, 'circle'|'square', Radius(1..101), ModePercent(0..100), margin)</c>
<l>    mtypes := ['circle','square']</l>
<l>    margins := ['mirrored','cyclic','continued',0,30,60,90,120,150,180,210,240,255]</l>
<c>    </c>
<l>    tuple_rand(1,R1)</l>
<l>    ms := mtypes[int(floor(R1*|mtypes|))]</l>
<c>        </c>
<l>    tuple_rand(1,R2)</l>
<l>    radius := 1 + floor(R2 * 101)</l>
<c>    </c>
<l>    tuple_rand(1,R3)</l>
<l>    mp := floor(R3*101)</l>
<c>    </c>
<l>    tuple_rand(1,R4)</l>
<l>    mg := margins[int(floor(R4*|margins|))]</l>
<c>    </c>
<l>    get_image_type(ImageIn, Type)</l>
<l>    if(Type != 'byte' and Type != 'uint2' and Type != 'int2' and Type != 'int4' and Type != 'real')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'byte')</l>
<l>    endif</l>
<l>    if (type(mg) == 'string')</l>
<l>        dual_rank (ImageIn, ImageOut, ms, radius, mp, mg)</l>
<l>    else</l>
<l>        dual_rank (ImageIn, ImageOut, ms, radius, mp, mg)</l>
<l>    endif</l>
<c>    </c>
<l>    ParamDesc := 'dual_rank(' + ms + ',r=' + radius + ',mp=' + mp + ',m=' + mg + ')'</l>
<c>    * (DualRank.Execute) :contentReference[oaicite:4]{index=4}</c>
<c></c>
<l>elseif (F == 'eliminate_min_max')</l>
<l>    * eliminate_min_max(ImageIn, ImageOut, MaskW, MaskH, Gap, Mode)</l>
<c>    * W/H odd 3..31; Gap 1..40; Mode {1,2,3}</c>
<c>    </c>
<l>    odds := [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31]</l>
<c>    </c>
<l>    tuple_rand(1,R1)</l>
<l>    mw := odds[floor(R1*|odds|)]</l>
<c>   </c>
<l>    tuple_rand(1,R2)</l>
<l>    mh := odds[floor(R2*|odds|)]</l>
<c>    </c>
<l>    tuple_rand(1,R3)</l>
<l>    gap := 1 + floor(R3*40)</l>
<c>    </c>
<l>    modes := [1,2,3]</l>
<c>   </c>
<l>    tuple_rand(1,R4)</l>
<l>    mode := modes[int(floor(R4*|modes|))]</l>
<c>   </c>
<l>    get_image_type(ImageIn, Type)</l>
<l>    if(Type != 'byte' and Type != 'uint2')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'byte')</l>
<l>    endif</l>
<l>    get_image_size (ImageIn, W, H)</l>
<l>    eliminate_min_max (ImageIn, ImageOut, min([W,mw]), min([H,mh]), gap, mode)</l>
<l>    ParamDesc := 'eliminate_min_max(' + mw + 'x' + mh + ',gap=' + gap + ',mode=' + mode + ')'</l>
<c>    * (EliminateMinMax.Execute) :contentReference[oaicite:5]{index=5}</c>
<c></c>
<l>elseif (F == 'equ_histo_image')</l>
<l>    get_image_type(ImageIn, Type)</l>
<l>    if(Type != 'byte' and Type != 'uint2')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'byte')</l>
<l>    endif</l>
<l>    equ_histo_image (ImageIn, ImageOut)</l>
<l>    ParamDesc := 'equ_histo_image()'</l>
<c>    * (EquHistoImage.Execute) :contentReference[oaicite:6]{index=6}</c>
<c></c>
<l>elseif (F == 'gauss_filter')</l>
<c>    * gauss_filter(ImageIn, ImageOut, MaskSize) with {3,5,7,9,11}</c>
<l>    sizes := [3,5,7,9,11]</l>
<c>        </c>
<l>    tuple_rand(1,R1)</l>
<l>    ms := sizes[int(floor(R1*|sizes|))]</l>
<c>    </c>
<l>    get_image_type(ImageIn, Type)</l>
<l>    if(Type != 'byte' and Type != 'uint2' and Type != 'int2' and Type != 'int4' and Type != 'real')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'byte')</l>
<l>    endif</l>
<l>    gauss_filter (ImageIn, ImageOut, ms)</l>
<l>    ParamDesc := 'gauss_filter(' + ms + ')'</l>
<c>    * (GaussFilter.Execute) :contentReference[oaicite:7]{index=7}</c>
<c></c>
<l>elseif (F == 'gray_range_rect')</l>
<c>    * gray_range_rect(ImageIn, ImageOut, MaskH, MaskW) with 3..511</c>
<c>    </c>
<l>    tuple_rand(1,R1)</l>
<l>    mh := 3 + floor(R1*509)</l>
<c>        </c>
<l>    tuple_rand(1,R2)</l>
<l>    mw := 3 + floor(R2*509)</l>
<c>    </c>
<l>    get_image_type(ImageIn, Type)</l>
<l>    if(Type != 'byte' and Type != 'uint2' and Type != 'real' and Type != 'cyclic' and Type != 'int2' and Type != 'int4')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'byte')</l>
<l>    endif</l>
<l>    gray_range_rect (ImageIn, ImageOut, mh, mw)</l>
<l>    ParamDesc := 'gray_range_rect(' + mh + 'x' + mw + ')'</l>
<c>    * (GrayRangeRect.Execute) :contentReference[oaicite:8]{index=8}</c>
<c></c>
<l>elseif (F == 'highpass_image')</l>
<c>    * highpass_image(ImageIn, ImageOut, MaskW, MaskH) (odd typical)</c>
<c>    </c>
<l>    odds := [3,5,7,9,11]</l>
<c>    </c>
<l>    tuple_rand(1,R1)</l>
<l>    mw := odds[int(floor(R1*|odds|))]</l>
<c>    </c>
<l>    tuple_rand(1,R2)</l>
<l>    mh := odds[int(floor(R2*|odds|))]</l>
<c>    </c>
<l>    get_image_type(ImageIn, Type)</l>
<l>    if(Type != 'byte' and Type != 'uint2')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'byte')</l>
<l>    endif</l>
<l>    highpass_image (ImageIn, ImageOut, mw, mh)</l>
<l>    ParamDesc := 'highpass_image(' + mw + 'x' + mh + ')'</l>
<c>    * (HighpassImage.Execute) :contentReference[oaicite:9]{index=9}</c>
<c></c>
<l>elseif (F == 'kirsch_amp')</l>
<l>    get_image_type(ImageIn, Type)</l>
<l>    if(Type != 'byte' and Type != 'int2' and Type != 'uint2')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'byte')</l>
<l>    endif</l>
<l>    kirsch_amp (ImageIn, ImageOut)</l>
<l>    ParamDesc := 'kirsch_amp()'</l>
<c>    * (KirschAmp.Execute) :contentReference[oaicite:10]{index=10}</c>
<c>    </c>
<l>elseif (F == 'laplace')</l>
<l>    * laplace(ImageIn, ImageOut, ResultType, MaskSize, FilterMask)</l>
<c>    * From node: result types include 'absolute','signed',...; masks sizes (3,5,7,9,11,13); connectivity 'n_4','n_8','n_8_isotropic'</c>
<l>    rtypes := ['absolute','absolute_binomial','signed','signed_binomial','signed_clipped','signed_clipped_binomial']</l>
<l>    nconn  := ['n_4','n_8','n_8_isotropic']</l>
<l>    sizes  := [3,5,7,9,11,13]</l>
<c>        </c>
<l>    tuple_rand(1,R1)</l>
<l>    rt := rtypes[int(floor(R1*|rtypes|))]</l>
<c>        </c>
<l>    tuple_rand(1,R2)</l>
<l>    sz := sizes[int(floor(R2*|sizes|))]</l>
<c>        </c>
<l>    tuple_rand(1,R3)</l>
<l>    nc := nconn[int(floor(R3*|nconn|))]</l>
<c>        </c>
<c>    * Ensure type compatibility</c>
<c>        </c>
<l>    get_image_type (ImageIn, _t)</l>
<c>        </c>
<l>    if (_t != 'byte' and _t != 'uint2')</l>
<l>        convert_image_type (ImageIn, ImageIn, 'uint2')</l>
<l>    endif</l>
<c>    </c>
<l>    laplace (ImageIn, ImageOut, rt, sz, nc) </l>
<l>    ParamDesc := 'laplace(' + rt + ',' + sz + ',' + nc + ')'</l>
<c>    * (Laplace.Execute parameters) :contentReference[oaicite:11]{index=11}</c>
<c>    </c>
<l>elseif (F == 'roberts')</l>
<c>    * roberts(ImageIn, ImageOut, 'gradient_max'|'gradient_sum'|'roberts_max')        </c>
<l>    opts := ['gradient_max','gradient_sum','roberts_max']</l>
<l>    tuple_rand(1,R1)</l>
<l>    opt := opts[int(floor(R1*|opts|))]</l>
<c>  </c>
<l>    get_image_type (ImageIn, _t)</l>
<c>        </c>
<l>    if (_t != 'byte' and _t != 'uint2' and _t != 'int2')</l>
<l>        convert_image_type (ImageIn, ImageIn, 'uint2')</l>
<l>    endif</l>
<c>    </c>
<l>    roberts (ImageIn, ImageOut, opt)</l>
<l>    ParamDesc := 'roberts(' + opt + ')'</l>
<c>    * (Roberts.Execute) :contentReference[oaicite:12]{index=12}</c>
<c>    </c>
<l>elseif (F == 'gauss')</l>
<l>    Sigmas := [3,5,7,9,11]</l>
<c>    </c>
<l>    tuple_rand(1,R1) </l>
<c>    </c>
<l>    Sigma := Sigmas[int(floor(R1*|Sigmas|))]</l>
<l>    get_image_type(ImageIn, Type)</l>
<c>        </c>
<l>    if(Type != 'int4')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'int4')</l>
<c>    </c>
<l>    endif </l>
<l>    gauss_image (ImageIn, ImageOut, Sigma)</l>
<l>    ParamDesc := 'gauss(sigma=' + Sigma + ')'</l>
<c></c>
<l>elseif (F == 'mean')</l>
<c>    </c>
<l>    tuple_rand(1, R1)</l>
<l>    mw := 3 + floor(R1 * 13)</l>
<c>    </c>
<l>    tuple_mod(int(mw),2,mod2)</l>
<l>    mw := mw - (1 - mod2)</l>
<c>        </c>
<l>    tuple_rand(1, R2)</l>
<l>    mh := 3 + floor(R2 * 13)</l>
<l>    tuple_mod(int(mh),2,mod2b)</l>
<l>    mh := mh - (1 - mod2b)</l>
<c>        </c>
<l>    get_image_type(ImageIn, Type)</l>
<l>    if(Type != 'byte' and Type != 'uint2' and Type != 'int2' and Type != 'int4' and Type != 'real')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'int4')</l>
<l>    endif</l>
<c>    </c>
<l>    mean_image (ImageIn, ImageOut, mw, mh)</l>
<l>    ParamDesc := 'mean(' + mw + 'x' + mh + ')'</l>
<c></c>
<l>elseif (F == 'median')</l>
<l>    tuple_rand(1, R1)</l>
<l>    Radius := 1 + floor(R1 * 7)</l>
<c>    </c>
<l>    get_image_type(ImageIn, Type)</l>
<c>    </c>
<l>    if(Type != 'byte' and Type != 'uint2' and Type != 'int2' and Type != 'int4' and Type != 'real')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'int4')</l>
<l>    endif</l>
<l>    median_image (ImageIn, ImageOut, 'circle', Radius, 'mirrored')</l>
<l>    ParamDesc := 'median(circle,r=' + Radius + ')'</l>
<c></c>
<l>elseif (F == 'sobel_amp')</l>
<l>    FT := ['sum_abs','sum_sqrt','x','y','sum_abs_binomial','sum_sqrt_binomial','x_binomial','y_binomial']</l>
<c>    </c>
<l>    ms := [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39]</l>
<c>    </c>
<l>    tuple_rand(1, R1)</l>
<l>    tIdx := int(floor(R1 * |FT|))</l>
<c>    </c>
<l>    if (tIdx &gt;= |FT|) </l>
<l>        tIdx := |FT| - 1 </l>
<l>    endif</l>
<c>        </c>
<l>    tuple_rand(1, R2)</l>
<l>    mIdx := floor(R2 * |ms|)</l>
<l>    if (mIdx &gt;= |ms|)</l>
<l>        mIdx := |ms| - 1</l>
<l>    endif</l>
<c>    </c>
<l>    try</l>
<l>        sobel_amp (ImageIn, ImageOut, FT[int(tIdx)], ms[int(mIdx)])</l>
<l>    catch (Exception) </l>
<l>        get_image_type(ImageIn, emptType)</l>
<l>        get_image_size(ImageIn, emptWidth, emptHeight)</l>
<l>        gen_image_const(ImageOut, emptType, emptWidth, emptHeight)</l>
<l>    endtry</l>
<l>    ParamDesc := 'sobel_amp(' + FT[tIdx] + ',' + ms[mIdx] + ')'</l>
<c></c>
<c></c>
<l>elseif (F == 'gray_open')</l>
<l>    MaskWidth := [3,5,7,9,11,13,15]</l>
<l>    MaskHeight := [3,5,7,9,11,13,15]</l>
<l>    MaskShape := ['octagon','rectangle','rhombus']</l>
<c>        </c>
<l>    tuple_rand(1,R1)</l>
<l>    wdx := int(floor(R1*|MaskWidth|))</l>
<c>        </c>
<l>    tuple_rand(1,R2)</l>
<l>    hdx := int(floor(R2*|MaskHeight|))</l>
<c>        </c>
<l>    tuple_rand(1,R3)</l>
<l>    sdx := int(floor(R3*|MaskShape|))</l>
<c>        </c>
<l>    get_image_type(ImageIn, Type)</l>
<c>        </c>
<l>    if(Type != 'byte' and Type != 'uint2') </l>
<l>        convert_image_type(ImageIn, ImageIn, 'uint2') </l>
<l>    endif</l>
<c>        </c>
<l>    try</l>
<l>        gray_opening_shape (ImageIn, ImageOut, MaskWidth[wdx], MaskHeight[hdx], MaskShape[sdx])</l>
<l>    catch (Exception) </l>
<l>        get_image_type(ImageIn, emptType)</l>
<l>        get_image_size(ImageIn, emptWidth, emptHeight)</l>
<l>        gen_image_const(ImageOut, emptType, emptWidth, emptHeight)</l>
<l>    endtry</l>
<l>    ParamDesc := 'gray_open(' + MaskShape[sdx] + ',' + MaskWidth[wdx] + 'x' + MaskHeight[hdx] + ')'</l>
<c></c>
<l>elseif (F == 'gray_close')</l>
<l>    MaskWidth := [3,5,7,9,11,13,15]</l>
<l>    MaskHeight := [3,5,7,9,11,13,15]        </l>
<l>    MaskShape := ['octagon','rectangle','rhombus']</l>
<c>        </c>
<l>    tuple_rand(1,R1)</l>
<l>    wdx := int(floor(R1*|MaskWidth|))</l>
<c>        </c>
<l>    tuple_rand(1,R2)</l>
<l>    hdx := int(floor(R2*|MaskHeight|))</l>
<c>        </c>
<l>    tuple_rand(1,R3)</l>
<l>    sdx := int(floor(R3*|MaskShape|))</l>
<c>        </c>
<l>    get_image_type(ImageIn, Type)</l>
<c>        </c>
<l>    if(Type != 'byte' and Type != 'uint2')</l>
<l>        convert_image_type(ImageIn, ImageIn, 'uint2')</l>
<l>    endif</l>
<c>    </c>
<l>    try</l>
<l>        gray_closing_shape (ImageIn, ImageOut, MaskWidth[wdx], MaskHeight[hdx], MaskShape[sdx])</l>
<l>    catch (Exception) </l>
<l>        get_image_type(ImageIn, emptType)</l>
<l>        get_image_size(ImageIn, emptWidth, emptHeight)</l>
<l>        gen_image_const(ImageOut, emptType, emptWidth, emptHeight)</l>
<l>    endtry</l>
<l>    ParamDesc := 'gray_close(' + MaskShape[sdx] + ',' + MaskWidth[wdx] + 'x' + MaskHeight[hdx] + ')'</l>
<c></c>
<l>else</l>
<l>    copy_image (ImageIn, ImageOut)</l>
<l>    ParamDesc := 'noop'</l>
<l>endif</l>
<c></c>
<l>return()</l>
</body>
<docu id="apply_random_filter">
<parameters>
<parameter id="FilterNames"/>
<parameter id="ImageIn"/>
<parameter id="ImageOut"/>
<parameter id="ParamDesc"/>
<parameter id="text"/>
</parameters>
</docu>
</procedure>
<procedure name="segment_to_region">
<interface>
<io>
<par name="Img" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionOut" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="UsedThr" base_type="ctrl" dimension="0"/>
<par name="SegDesc" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* -- Segment an image into a region using auto threshold (random method + light/dark)</c>
<c>* segment_to_region := procedure (Img : RegionOut, UsedThr, SegDesc :) </c>
<l>Methods := ['max_separability','smooth_histo']</l>
<l>Lights  := ['light','dark']</l>
<c>    </c>
<l>tuple_rand(1, Rand)</l>
<l>mIdx := floor(Rand * |Methods|)</l>
<l>if (mIdx &gt;= |Methods|) </l>
<l>    mIdx := |Methods| - 1 </l>
<l>endif</l>
<c>    </c>
<l>tuple_rand(1, Rand)</l>
<l>lIdx := floor(Rand * |Lights|)</l>
<l>if (lIdx &gt;= |Lights|)</l>
<l>    lIdx := |Lights|  - 1</l>
<l>endif</l>
<c>    </c>
<l>get_image_type(Img, Type)</l>
<l>if(Type != 'byte' and Type != 'uint2' and Type != 'real')</l>
<l>    convert_image_type(Img, Img, 'uint2')</l>
<l>endif</l>
<l>binary_threshold (Img, RegionOut, Methods[mIdx], Lights[lIdx], UsedThr)</l>
<l>SegDesc := 'binary_threshold(' + Methods[mIdx] + ',' + Lights[lIdx] + '; thr=' + UsedThr + ')'</l>
<c></c>
<c>* ==================================================================</c>
<l>Methods := ['binary_threshold','auto_threshold','fast_threshold']</l>
<c></c>
<l>tuple_rand(1,R)</l>
<l>which := floor(R * |Methods|)</l>
<c></c>
<l>if (which == 0)</l>
<c>    * BinaryThreshold (max_separability|smooth_histo, light|dark)</c>
<l>    mset := ['max_separability','smooth_histo']</l>
<l>    lset := ['light','dark']</l>
<c>    </c>
<l>    tuple_rand(1,r1)</l>
<l>    m := mset[floor(r1*|mset|)]</l>
<c>    </c>
<l>    tuple_rand(1,r2)</l>
<l>    l := lset[floor(r2*|lset|)]</l>
<c>    </c>
<l>    binary_threshold (Img, RegionOut, m, l, UsedThr)</l>
<l>    SegDesc := 'binary_threshold(' + m + ',' + l + '; thr=' + UsedThr + ')'</l>
<c>    * (BinaryThreshold.Execute) :contentReference[oaicite:13]{index=13}</c>
<c></c>
<l>elseif (which == 1)</l>
<c>    * AutoThreshold with Sigma in {0,0.5,1,2,3,4,5}</c>
<l>    sset := [0,0.5,1,2,3,4,5]</l>
<c>    </c>
<l>    tuple_rand(1,rs)</l>
<l>    s := sset[floor(rs*|sset|)]</l>
<c>    </c>
<l>    auto_threshold (Img, RegionOut, s)</l>
<l>    SegDesc := 'auto_threshold(sigma=' + s$'.1f' + ')'</l>
<l>    UsedThr := -1</l>
<c>    * (AutoThreshold.Execute) :contentReference[oaicite:14]{index=14}</c>
<c></c>
<l>else</l>
<c>    * FastThreshold: min_gray (0..254), max_gray = min_gray + offset(0..255 clamped), min_size 2..200</c>
<c>    </c>
<l>    tuple_rand(1,r1)</l>
<l>    minGray := floor(r1*255)</l>
<c>    </c>
<l>    tuple_rand(1,r2)</l>
<l>    off := floor(r2*256)</l>
<c>    </c>
<l>    MaxGray := min([255, minGray + off])</l>
<c>    </c>
<l>    tuple_rand(1,r3)</l>
<l>    minSize := 2 + floor(r3*199)</l>
<c>    </c>
<l>    fast_threshold (Img, RegionOut, minGray, MaxGray, minSize)</l>
<l>    SegDesc := 'fast_threshold(min=' + minGray + ', max=' + MaxGray + ', minSize=' + minSize + ')'</l>
<l>    UsedThr := -1</l>
<c>    * (FastThreshold.Execute) :contentReference[oaicite:15]{index=15}</c>
<l>endif</l>
<c></c>
<l>Methods := ['binary_threshold','auto_threshold','fast_threshold']</l>
<c></c>
<l>tuple_rand(1,R)</l>
<l>which := floor(R * |Methods|)</l>
<c></c>
<l>if (which == 0)</l>
<c>    * BinaryThreshold (max_separability|smooth_histo, light|dark)</c>
<l>    mset := ['max_separability','smooth_histo']</l>
<l>    lset := ['light','dark']</l>
<c>        </c>
<l>    tuple_rand(1,r1)</l>
<l>    m := mset[floor(r1*|mset|)]</l>
<c>        </c>
<l>    tuple_rand(1,r2)</l>
<l>    l := lset[floor(r2*|lset|)]</l>
<c>        </c>
<l>    binary_threshold (Img, RegionOut, m, l, UsedThr)</l>
<l>    SegDesc := 'binary_threshold(' + m + ',' + l + '; thr=' + UsedThr + ')'</l>
<c>    * (BinaryThreshold.Execute) :contentReference[oaicite:13]{index=13}</c>
<c>    </c>
<l>elseif (which == 1)</l>
<c>    * AutoThreshold with Sigma in {0,0.5,1,2,3,4,5}</c>
<c>        </c>
<l>    sset := [0,0.5,1,2,3,4,5]</l>
<c>        </c>
<l>    tuple_rand(1,rs)</l>
<l>    s := sset[floor(rs*|sset|)]</l>
<c>    </c>
<l>    auto_threshold (Img, RegionOut, s)</l>
<l>    SegDesc := 'auto_threshold(sigma=' + s$'.1f' + ')'</l>
<l>    UsedThr := -1</l>
<c>    * (AutoThreshold.Execute) :contentReference[oaicite:14]{index=14}</c>
<c></c>
<l>else</l>
<c>    * FastThreshold: min_gray (0..254), max_gray = min_gray + offset(0..255 clamped), min_size 2..200</c>
<c>        </c>
<l>    tuple_rand(1,r1)</l>
<l>    minGray := floor(r1*255)</l>
<c>       </c>
<l>    tuple_rand(1,r2)</l>
<l>    off := floor(r2*256)</l>
<c>        </c>
<l>    MaxGray := min([255, minGray + off])</l>
<c>        </c>
<l>    tuple_rand(1,r3)</l>
<l>    minSize := 2 + floor(r3*199)</l>
<c>        </c>
<l>    fast_threshold (Img, RegionOut, minGray, MaxGray, minSize)</l>
<c>       </c>
<l>    SegDesc := 'fast_threshold(min=' + minGray + ', max=' + MaxGray + ', minSize=' + minSize + ')'</l>
<l>    UsedThr := -1</l>
<c>    * (FastThreshold.Execute) :contentReference[oaicite:15]{index=15} </c>
<l>endif</l>
</body>
<docu id="segment_to_region">
<parameters>
<parameter id="Img"/>
<parameter id="RegionOut"/>
<parameter id="SegDesc"/>
<parameter id="UsedThr"/>
</parameters>
</docu>
</procedure>
<procedure name="mcc_region">
<interface>
<io>
<par name="PredRegion" base_type="iconic" dimension="0"/>
<par name="GTRegion" base_type="iconic" dimension="0"/>
</io>
<ic>
<par name="Width" base_type="ctrl" dimension="0"/>
<par name="Height" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="MCC" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* -- Compute MCC between predicted region and GT region for one image</c>
<c>* mcc_region := procedure (PredRegion, GTRegion, Width, Height : MCC :) </c>
<c></c>
<c>* Intersection (TP)</c>
<l>intersection (PredRegion, GTRegion, R_tp)</l>
<l>area_center (R_tp, TP, Row, Col)</l>
<c></c>
<c>* FP = Pred minus GT</c>
<l>difference (PredRegion, GTRegion, R_fp)</l>
<l>area_center (R_fp, FP, Row, Col)</l>
<c></c>
<c>* FN = GT minus Pred</c>
<l>difference (GTRegion, PredRegion, R_fn)</l>
<l>area_center (R_fn, FN, Row, Col)</l>
<c></c>
<c>* TN = total - (TP+FP+FN)</c>
<l>Total := Width * Height</l>
<l>TN := max2(0, Total - (TP + FP + FN))</l>
<c></c>
<l>tuple_add(TP, FP, TP_plus_FP)</l>
<l>tuple_add(TP, FN, TP_plus_FN)</l>
<l>tuple_add(TN, FP, TN_plus_FP)</l>
<l>tuple_add(TN, FN, TN_plus_FN)</l>
<c></c>
<l>tuple_real(TN_plus_FN, TN_plus_FN)</l>
<l>tuple_real(TP_plus_FN, TP_plus_FN)</l>
<l>tuple_real(TN_plus_FP, TN_plus_FP)</l>
<l>tuple_real(TN_plus_FN, TN_plus_FN)</l>
<c></c>
<l>tuple_mult(TP_plus_FP, TP_plus_FN, Prod)</l>
<l>tuple_mult(Prod, TN_plus_FP, Prod)</l>
<l>tuple_mult(Prod, TN_plus_FN, Prod)</l>
<l>*Den := sqrt((TP+FP) * (TP+FN) * (TN+FP) * (TN+FN))</l>
<c></c>
<l>tuple_sqrt(Prod, Den)</l>
<c></c>
<l>MCC := 0.0</l>
<l>if (Den &lt;= 0)</l>
<l>    MCC := 0.0</l>
<l>else</l>
<l>    *MCC := ((TP * TN) - (FP * FN)) / Den</l>
<l>    tuple_mult(TP, TN, TP_mult_TN)</l>
<l>    tuple_mult(FP, FN, FP_mult_FN)</l>
<c>        </c>
<l>    for Idx := 0 to |TP_plus_FN| - 1 by 1</l>
<l>        numerator := TP_plus_FN[Idx] - FP_mult_FN[Idx]</l>
<l>        if(Den[Idx] &gt; 0.0)</l>
<l>            MCC := MCC + (numerator / Den[Idx])</l>
<l>        endif</l>
<l>    endfor</l>
<l>    MCC := MCC / |TP_mult_TN|</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="mcc_region">
<parameters>
<parameter id="GTRegion"/>
<parameter id="Height"/>
<parameter id="MCC"/>
<parameter id="PredRegion"/>
<parameter id="Width"/>
</parameters>
</docu>
</procedure>
<procedure name="postprocess_region_random">
<interface>
<io>
<par name="RegionIn" base_type="iconic" dimension="0"/>
</io>
<oo>
<par name="RegionOut" base_type="iconic" dimension="0"/>
</oo>
<oc>
<par name="PostDescOut" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<c>* =========================</c>
<c>* Region post-processing (region -&gt; region)</c>
<c>* Randomly apply one region operator from OperatorNodes</c>
<c>* =========================</c>
<l>Ops := ['closing','dilation1','erosion1','union1','union2','connection','area_to_rectangle']</l>
<c></c>
<l>tuple_rand(1,R)</l>
<l>op := Ops[floor(R*|Ops|)]</l>
<c></c>
<l>PostDescOut := ''</l>
<c></c>
<l>try</l>
<l>    select_obj(RegionIn, ObjectSelected, 0)</l>
<l>catch (Exception)</l>
<l>    gen_empty_region (RegionOut)</l>
<l>    PostDescOut := 'empty_input'</l>
<l>endtry</l>
<c></c>
<l>if (op == 'closing')</l>
<l>*     closing(RegionIn, RegionOut, radius)</l>
<l>    tuple_rand(1,r1)</l>
<l>    A := 1 + floor(r1*300.0)</l>
<c>    </c>
<l>    tuple_rand(1,r1)</l>
<l>    B := 1 + floor(r1*300.0)</l>
<c>    </c>
<l>    tuple_rand(1,r1)</l>
<l>    radius := 1 + floor(r1*300.0)</l>
<c>    </c>
<l>    gen_circle(SE, A, B, radius)</l>
<c>    </c>
<l>    closing(RegionIn, SE, RegionOut)</l>
<c>        </c>
<l>    PostDescOut := 'closing(r=' + radius + ')'</l>
<c>    * (Closing.Execute) :contentReference[oaicite:0]{index=0}</c>
<c></c>
<l>elseif (op == 'dilation1')</l>
<c>    * dilation1(RegionIn, RegionOut, radius)</c>
<l>    tuple_rand(1,r1)</l>
<l>    A := 1 + floor(r1*300.0)</l>
<c>    </c>
<l>    tuple_rand(1,r1)</l>
<l>    B := 1 + floor(r1*300.0)</l>
<c>    </c>
<l>    tuple_rand(1,r1)</l>
<l>    radius := 1 + floor(r1*300.0)    </l>
<c>        </c>
<l>    gen_circle(SE, A, B, radius)</l>
<l>    dilation1(RegionIn, SE, RegionOut, 1)</l>
<l>    PostDescOut := 'dilation1(r=' + radius + ')'</l>
<c>    * (Dilation1.Execute) :contentReference[oaicite:1]{index=1}</c>
<c>    </c>
<l>elseif (op == 'erosion1')  </l>
<c>    * erosion1(RegionIn, RegionOut, radius)</c>
<l>    tuple_rand(1,r1)</l>
<l>    A := 1 + floor(r1*300.0)</l>
<c>    </c>
<l>    tuple_rand(1,r1)</l>
<l>    B := 1 + floor(r1*300.0)</l>
<c>    </c>
<l>    tuple_rand(1,r1)</l>
<l>    radius := 1 + floor(r1*300.0)    </l>
<c>    </c>
<l>    gen_circle(SE, A, B, radius)</l>
<l>    erosion1 (RegionIn, SE, RegionOut, 1)</l>
<l>    PostDescOut := 'erosion1(r=' + radius + ')'</l>
<c>    * (Erosion1.Execute) :contentReference[oaicite:2]{index=2}</c>
<c>    </c>
<l>elseif (op == 'union1')</l>
<l>    *union1(RegionIn, RegionOut)</l>
<l>    union1 (RegionIn, RegionOut) </l>
<l>    PostDescOut := 'union1()'</l>
<c>    * (Union1.Execute) :contentReference[oaicite:3]{index=3}</c>
<c></c>
<c>    </c>
<l>elseif (op == 'union2')</l>
<c>    * union two randomly selected single regions (if possible)</c>
<l>    count_obj(RegionIn, Count)</l>
<l>    if (Count &gt;= 2)</l>
<l>        tuple_rand(1, r1)</l>
<l>        idx1 := int(1 + floor(r1*Count))</l>
<l>        tuple_rand(1, r2)</l>
<l>        idx2 := int(1 + floor(r2*Count))</l>
<l>        if (idx2 == idx1)</l>
<l>            tuple_mod(idx1, Count, Mod)</l>
<l>            idx2 := Mod + 1</l>
<l>        endif</l>
<l>        select_obj(RegionIn, RegA, int(idx1))</l>
<l>        select_obj(RegionIn, RegB, int(idx2))</l>
<l>        union2(RegA, RegB, RegionOut)</l>
<l>        PostDescOut := 'union2()'</l>
<l>    elseif (Count == 1)</l>
<c>        * only one object; union2 degenerates to identity</c>
<l>        copy_obj(RegionIn, RegionOut, 1, -1)</l>
<l>        PostDescOut := 'union2(identity)'</l>
<l>    else</l>
<c>        * empty input</c>
<l>        gen_empty_region(RegionOut)</l>
<l>        PostDescOut := 'union2(empty)'</l>
<l>    endif</l>
<l>elseif (op == 'connection')</l>
<l>    * connection(RegionIn, RegionOut)</l>
<l>    connection (RegionIn, RegionOut)</l>
<l>    PostDescOut := 'connection()'</l>
<c>    * (Connection.Execute) :contentReference[oaicite:5]{index=5}</c>
<c></c>
<l>elseif (op == 'area_to_rectangle')</l>
<c>    * area_to_rectangle(RegionIn, RegionOut)W</c>
<l>    area_center(RegionIn, Area, Row, Column)</l>
<l>    Num:= | Area |</l>
<l>    gen_empty_region(RegionOut)</l>
<l>    for Index1 := 1 to Num by 1</l>
<l>        select_obj(RegionIn, obj, Index1)</l>
<l>        smallest_rectangle1(obj, Row11, Column11, Row21, Column21)</l>
<l>        gen_rectangle1(Rectangle, Row11, Column11, Row21, Column21)</l>
<l>        union2(RegionOut, Rectangle, RegionOut)</l>
<l>    endfor</l>
<l>    PostDescOut := 'area_to_rectangle()'</l>
<c>    * (AreaToRectangle.Execute) :contentReference[oaicite:6]{index=6}</c>
<c></c>
<l>else</l>
<l>    copy_obj (RegionIn, RegionOut, 1, -1)</l>
<l>    PostDescOut := 'noop'</l>
<l>endif</l>
<c></c>
<l>return ()</l>
</body>
<docu id="postprocess_region_random">
<parameters>
<parameter id="PostDescOut"/>
<parameter id="RegionIn"/>
<parameter id="RegionOut"/>
</parameters>
</docu>
</procedure>
<procedure name="write_to_file">
<interface>
<ic>
<par name="ResultDirPath" base_type="ctrl" dimension="0"/>
<par name="Line" base_type="ctrl" dimension="0"/>
</ic>
</interface>
<body>
<l>file_exists(ResultDirPath, FileExists)</l>
<l>resultFileContent := ''</l>
<l>if(FileExists)    </l>
<l>    open_file(ResultDirPath, 'input', FileHandle)</l>
<l>    while(true)</l>
<l>        fread_string(FileHandle,InputLine,IsEOF)</l>
<l>        resultFileContent := resultFileContent + '\n' + InputLine</l>
<l>        if (IsEOF)</l>
<l>            break</l>
<l>        endif</l>
<l>    endwhile</l>
<l>    close_file(FileHandle)</l>
<l>endif</l>
<c></c>
<l>open_file(ResultDirPath, \
          'output', \
          FileHandle)</l>
<l>fwrite_string(FileHandle, Line + resultFileContent)</l>
<l>close_file(FileHandle)</l>
<c></c>
<l>return ()</l>
</body>
<docu id="write_to_file">
<parameters>
<parameter id="Line"/>
<parameter id="ResultDirPath"/>
</parameters>
</docu>
</procedure>
<procedure name="read_from_file">
<interface>
<ic>
<par name="ResultDirPath" base_type="ctrl" dimension="0"/>
</ic>
<oc>
<par name="FileContent" base_type="ctrl" dimension="0"/>
</oc>
</interface>
<body>
<l>FileContent := ''</l>
<l>file_exists(ResultDirPath,FileExists)</l>
<l>if(FileExists == 0)</l>
<l>    return()</l>
<l>endif</l>
<c></c>
<l>open_file(ResultDirPath, 'input', FileHandle)</l>
<c></c>
<l>while(true)</l>
<l>    fread_string(FileHandle,Line,IsEOF)</l>
<l>    FileContent := FileContent + '\n' + Line</l>
<l>    if (IsEOF)</l>
<l>        break</l>
<l>    endif</l>
<l>endwhile</l>
<l>close_file(FileHandle)</l>
<l>return ()</l>
</body>
<docu id="read_from_file">
<parameters>
<parameter id="FileContent"/>
<parameter id="ResultDirPath"/>
</parameters>
</docu>
</procedure>
</hdevelop>
